# Synchronized和锁

首先需要明确的一点是：Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁，也就是说我们常听到的类锁其实也是**对象锁**。

`synchronized`这个关键字，它翻译成中文就是“同步”的意思。

为避免竞争状态，应该防止多个线程同时进入程序的某一特定部分，程序中的这部分称为临界区。

通常使用**synchronized**关键字来给一段代码或一个方法上锁。

* 关键字在实例方法上，锁为当前实例

```
public synchronized void instanceLock() {
    // todo...
}
```

* 关键字在静态方法上，锁为当前Class对象

```
public static synchronized void classLock() {
    // todo...
}
```

* 关键字在代码块上，锁为括号里面的对象

```
public void blockLock() {
    Object o = new Object();
    synchronized (o) {
        // todo...
    }
}
```

**Java中的几种锁**

一个对象其实有四种锁状态，它们级别由低到高依次是：

* 无锁状态
* 偏向锁状态
* 轻量级锁状态
* 重量级锁状态

**偏向锁**

* 为什么要引入偏向锁？

因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。

* 偏向锁原理和升级过程

当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。

**轻量级锁**

* 为什么要引入轻量级锁？

轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

* 轻量级锁原理和升级过程

**线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord）**，然后使用**CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；**

如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，**线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。 自旋锁简单来说就是让线程2在循环中不断CAS**

但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，**如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。**

几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在`Stop The World`期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。如果想了解锁降级，请各位移步[这里](https://app.gitbook.com/s/-M3LDVHNCK0Dsr\_yy-II/duo-xian-cheng-ji-chu/Java%E9%94%81%E4%BC%98%E5%8C%96--JVM%E9%94%81%E9%99%8D%E7%BA%A7)。

**synchronized实现的原理**

synchronized是由JVM实现的一种互斥同步锁，如果你查看被synchronized修饰过的程序块编译后的字节码，你会发现生成了monitorenter和monitorexit两个字节码指令。当虚拟机执行到monitorenter指令时，首先要尝试获取对象的锁：**如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器+1；当执行monitorexit指令时，将锁的计数器-1；当计数器为0时，锁就被释放了**。

JVM规范规定JVM基于进入和退出 `Monitor` 对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。

`monitorenter`指令是在编译后插入到同步代码块的开始位置，而`monitorexit`是插入到方法结束处和异常处，JVM要保证每个`monitorenter`必须有对应的`monitorexit`与之配对。任何对象都有一个`monitor`与之关联，当且一个`monitor`被持有后，它将处于锁定状态。线程执行到 `monitorenter` 指令时，将会尝试获取对象所对应的 `monitor` 的所有权，即尝试获得对象的锁。

这里借用方大大的文章，请移步[这里](https://www.infoq.cn/article/java-se-16-synchronized)

**总结一下锁升级的过程**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200319095959853.png)

每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。

第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。

第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。

第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。

第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。

第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。

**synchronized锁重入**

* 关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁之后，再次请求此对象锁是可以可以再次得到这个对象的锁的。
* “可重入锁”的概念是：自己可以获得自己内部锁。假设有线程t1获得了某个对象的锁，此时这个对象锁还没有被释放，想再次获得这个对象的锁的时候还是可以获得的，如果不可重入锁的话，就会造成死锁。
